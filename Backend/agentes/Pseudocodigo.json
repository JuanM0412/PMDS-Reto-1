{
  "name": "Pseudocodigo",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "Pseudocodigo",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -1136,
        336
      ],
      "id": "ee9cce76-42c9-46d9-adc4-454cabc9b672",
      "name": "Webhook",
      "webhookId": "73d4e084-1bd2-4175-982e-1e7b84f0aaaa"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "46b38ad8-cb03-4e4c-a034-3396ef1595f1",
              "name": "run_id",
              "value": "={{ $json.body.run_id }}",
              "type": "string"
            },
            {
              "id": "7c1b204d-9a28-4763-8d0f-bdc34396d19b",
              "name": "is_feedback",
              "value": "={{ $json.body.is_feedback }}",
              "type": "string"
            },
            {
              "id": "381a0fd4-453c-4ff6-88a7-e99050f52fc5",
              "name": "feedback",
              "value": "={{ $json.body.feedback }}",
              "type": "string"
            },
            {
              "id": "f68fba2d-e1c8-4703-9940-af082ada77b3",
              "name": "context",
              "value": "={{ $json.body.context }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -928,
        336
      ],
      "id": "3aeb9c66-ad89-48b1-be2e-81d9ba6d042b",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Eres STATELESS.\n\nINPUT (objeto JSON):\n{\n\"context\": {{ $json.context }},\n\"is_feedback\": {{ $json.is_feedback }},\n\"feedback\": {{ $json.feedback }}\n}\n\nEl campo context contiene historias de usuario y requisitos funcionales. Debes analizar esas historias y producir piezas de pseudocódigo coherentes con ellas.\n\nOBJETIVO\nGenerar o actualizar pseudocódigo estructurado basado en las historias de usuario presentes en context.\n\nSALIDA OBLIGATORIA\nDebes responder con un único objeto JSON válido siguiendo exactamente este esquema:\n\n{\n\"artifact\": {\n\"user_story_pseudocode\": {\n\"<titulo_historia_1>\": \"<pseudocodigo_string>\",\n\"<titulo_historia_2>\": \"<pseudocodigo_string>\"\n}\n},\n\"changes_made\": {\n\"added\": [],\n\"removed\": [],\n\"modified\": []\n},\n\"justification\": \"\"\n}\n\nREGLAS CRÍTICAS (JSON ESTRICTO)\n\nTu respuesta debe ser SOLO JSON, sin texto antes o después.\n\nNO uses bloques Markdown (NO json, NO ).\n\nNO uses backticks (`) en ninguna parte.\n\nTodo el pseudocódigo debe ir como string JSON (entre comillas dobles).\n\nUsa saltos de línea como \"\\n\" dentro del string.\n\nSi necesitas comillas dentro del pseudocódigo, escápalas como \"\\\"\".\n\nNo incluyas comentarios fuera del JSON.\n\nINSTRUCCIONES FUNCIONALES\nSi is_feedback es false:\n\nAnaliza las historias de usuario en context.\n\nPara cada historia, genera una pieza de pseudocódigo estructurado e independiente.\n\nCada bloque debe incluir: nombre de función/procedimiento, ENTRADAS, SALIDAS, y pasos lógicos principales.\n\nMantén coherencia con microservicios: separa responsabilidades por dominio (p. ej. Auth, Perfil, Pagos) cuando aplique.\n\nSi is_feedback es true:\n\nAjusta únicamente el pseudocódigo necesario según feedback.\n\nMantén las partes no afectadas intactas.\n\nRegistra cambios en changes_made:\n\nadded: [\"...\"] funciones o bloques nuevos\n\nremoved: [\"...\"] funciones o bloques eliminados\n\nmodified: [\"...\"] funciones o bloques modificados\n\nREGLAS DE LOG\n\nSi creación inicial: added = [\"Creación inicial del pseudocódigo basado en historias de usuario\"]\n\nSi cambios: llena added/removed/modified con descripciones breves y específicas.\n\nJUSTIFICATION\nEn \"justification\" escribe mínimo 3 oraciones técnicas que:\n\nExpliquen cómo el pseudocódigo representa las historias.\n\nJustifiquen separación en funciones/servicios.\n\nReferencien coherencia con arquitectura de microservicios.\n\nIMPORTANTE\n\nNo generes requerimientos formales.\n\nNo generes historias de usuario nuevas.\n\nNo generes diseño técnico.",
        "options": {
          "systemMessage": "Eres un Arquitecto de Software especializado en modelado para Super Apps."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3.1,
      "position": [
        -752,
        336
      ],
      "id": "091ecce6-fad9-4d5e-954b-5ac8486ab334",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=http://host.docker.internal:8000/callbacks/agent/pseudocodigo",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "run_id",
              "value": "={{$node[\"Webhook\"].json[\"body\"][\"run_id\"]}}"
            },
            {
              "name": "content",
              "value": "={{$json}}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.4,
      "position": [
        -208,
        336
      ],
      "id": "1b9b258b-1e1a-433a-89db-83664d338c27",
      "name": "HTTP Request"
    },
    {
      "parameters": {
        "model": "meta-llama/llama-4-scout-17b-16e-instruct",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGroq",
      "typeVersion": 1,
      "position": [
        -816,
        528
      ],
      "id": "86333fa7-c095-4568-853c-f1726ab60358",
      "name": "Groq Chat Model",
      "credentials": {
        "groqApi": {
          "id": "6W1kVDttCFtf5042",
          "name": "Groq account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node (JavaScript)\n// Soluciona: \"Unexpected non-whitespace character after JSON...\"\n// Extrayendo el PRIMER JSON completo (objeto o array) por balanceo de llaves/corchetes.\n\nfunction getRaw(item) {\n  const j = item.json ?? {};\n  return j.output ?? j.text ?? j.message ?? j.content ?? j.data ?? j;\n}\n\nfunction extractFirstJsonValue(text) {\n  if (typeof text !== \"string\") text = String(text);\n\n  // Si viene dentro de ```json ... ``` o ``` ... ```, primero intenta sacar el contenido del fence\n  const fence = text.match(/```(?:json)?\\s*([\\s\\S]*?)\\s*```/i);\n  if (fence?.[1]) text = fence[1];\n\n  // Busca inicio de JSON: { o [\n  const startObj = text.indexOf(\"{\");\n  const startArr = text.indexOf(\"[\");\n  let start = -1;\n\n  if (startObj === -1) start = startArr;\n  else if (startArr === -1) start = startObj;\n  else start = Math.min(startObj, startArr);\n\n  if (start === -1) return null;\n\n  // Scanner para encontrar el final exacto del JSON (balanceando y respetando strings)\n  let inString = false;\n  let escape = false;\n  let depth = 0;\n  let opener = text[start];\n  let closer = opener === \"{\" ? \"}\" : \"]\";\n\n  for (let i = start; i < text.length; i++) {\n    const ch = text[i];\n\n    if (inString) {\n      if (escape) {\n        escape = false;\n      } else if (ch === \"\\\\\") {\n        escape = true;\n      } else if (ch === '\"') {\n        inString = false;\n      }\n      continue;\n    }\n\n    if (ch === '\"') {\n      inString = true;\n      continue;\n    }\n\n    if (ch === opener) depth++;\n    else if (ch === closer) depth--;\n\n    if (depth === 0) {\n      return text.slice(start, i + 1).trim();\n    }\n  }\n\n  // Si no cerró, no es JSON completo\n  return null;\n}\n\nfunction safeParseJson(text) {\n  // Limpieza ligera por si vienen comillas “ ”\n  const cleaned = text.replace(/[“”]/g, '\"').replace(/[‘’]/g, \"'\");\n  return JSON.parse(cleaned);\n}\n\n// --- MAIN ---\nconst out = [];\n\nfor (const item of items) {\n  const raw = getRaw(item);\n\n  // Si ya es objeto/array, pásalo directo\n  if (raw && typeof raw === \"object\") {\n    out.push({ json: raw });\n    continue;\n  }\n\n  const txt = String(raw);\n  const jsonStr = extractFirstJsonValue(txt);\n\n  if (!jsonStr) {\n    throw new Error(\n      \"No encontré un JSON completo en el texto. Primeros 300 chars:\\n\" +\n      txt.slice(0, 300)\n    );\n  }\n\n  const parsed = safeParseJson(jsonStr);\n  out.push({ json: parsed });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -400,
        336
      ],
      "id": "2c10b86e-4035-4d4d-9e86-7d533094e40b",
      "name": "Code in JavaScript"
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Groq Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "binaryMode": "separate",
    "availableInMCP": false
  },
  "versionId": "72f80160-ad91-4201-b5ab-1b9cadced9ff",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "b2c602997e13032fa05ecc33deb70e2fbde4447f9b25778661244630cfd2b3a6"
  },
  "id": "o1NC4mElWZDebkUp",
  "tags": []
}