{
  "name": "Pseudocodigo",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "Pseudocodigo",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -1088,
        16
      ],
      "id": "aeefabb9-3294-4b6a-bc27-2ee52114e02e",
      "name": "Webhook",
      "webhookId": "73d4e084-1bd2-4175-982e-1e7b84f0aaaa"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "46b38ad8-cb03-4e4c-a034-3396ef1595f1",
              "name": "run_id",
              "value": "={{ $json.body.run_id }}",
              "type": "string"
            },
            {
              "id": "7c1b204d-9a28-4763-8d0f-bdc34396d19b",
              "name": "is_feedback",
              "value": "={{ $json.body.is_feedback }}",
              "type": "string"
            },
            {
              "id": "381a0fd4-453c-4ff6-88a7-e99050f52fc5",
              "name": "feedback",
              "value": "={{ $json.body.feedback }}",
              "type": "string"
            },
            {
              "id": "f68fba2d-e1c8-4703-9940-af082ada77b3",
              "name": "context",
              "value": "={{ $json.body.context }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -880,
        16
      ],
      "id": "b7fc156a-7631-4581-97a6-baf215bd2f32",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Eres STATELESS.\n\nINPUT:\n{\n  \"context\":{{ $json.context }},\n  \"is_feedback\": {{ $json.is_feedback }},\n  \"feedback\": {{ $json.feedback }}\n}\n\nEl campo context contiene historias de usuario y requisitos funcionales.\nDebes analizar esas historias y producir piezas de pseudocódigo coherentes con ellas.\n\nOBJETIVO\n\nGenerar o actualizar pseudocódigo estructurado basado en las historias de usuario presentes en context.\n\nCada historia de usuario debe producir:\n\nUn bloque de pseudocódigo independiente.\n\nFunciones o procedimientos claramente definidos.\n\nEntradas, salidas y pasos lógicos principales.\n\nINSTRUCCIONES\n\nSi is_feedback es false:\n\nAnaliza las historias de usuario en context.\n\nPara cada historia, genera una pieza de pseudocódigo estructurado.\n\nEl pseudocódigo debe representar el flujo funcional principal.\n\nUtiliza nombres de funciones claros alineados con la historia.\n\nMantén consistencia con arquitecturas de microservicios (servicios separados cuando aplique).\n\nSi is_feedback es true:\n\nAjusta únicamente el pseudocódigo necesario según feedback.\n\nMantén las partes no afectadas intactas.\n\nDocumenta los cambios realizados.\n\nREGLAS DE LOG\n\nSi creación inicial:\n\nadded = [\"Creación inicial del pseudocódigo basado en historias de usuario\"]\n\n\nSi cambios:\n\nFunciones añadidas/eliminadas\n\nCambios en lógica del pseudocódigo\n\nAjustes de entradas/salidas\n\nJUSTIFICATION\n\nDebe:\n\nExplicar cómo el pseudocódigo representa las historias de usuario.\n\nJustificar la separación en funciones o servicios.\n\nReferenciar coherencia con arquitectura de microservicios.\n\nContener mínimo 3 oraciones técnicas.\n\nOUTPUT\n{\n  \"artifact\": {\n    \"user_story_pseudocode\": {}\n  },\n  \"changes_made\": {\n    \"added\": [],\n    \"removed\": [],\n    \"modified\": []\n  },\n  \"justification\": \"\"\n}\n\n\nSolo JSON válido.",
        "options": {
          "systemMessage": "Eres un Arquitecto de Software especializado en modelado para Super Apps."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3.1,
      "position": [
        -704,
        16
      ],
      "id": "ca61a89a-eae5-4e6a-964c-9f5c15961f8c",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=http://host.docker.internal:8000/callbacks/agent/pseudocodigo",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "run_id",
              "value": "={{$node[\"Webhook\"].json[\"body\"][\"run_id\"]}}"
            },
            {
              "name": "content",
              "value": "={{$json}}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.4,
      "position": [
        0,
        0
      ],
      "id": "291b1085-3a13-4539-abdb-066fbcda6458",
      "name": "HTTP Request"
    },
    {
      "parameters": {
        "model": "meta-llama/llama-4-scout-17b-16e-instruct",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGroq",
      "typeVersion": 1,
      "position": [
        -768,
        208
      ],
      "id": "0d0c2198-23a3-418d-8c78-09b82c501cb9",
      "name": "Groq Chat Model",
      "credentials": {
        "groqApi": {
          "id": "fRHaAKZDFLDwFFOT",
          "name": "Groq account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node (JavaScript)\n// Soluciona: \"Unexpected non-whitespace character after JSON...\"\n// Extrayendo el PRIMER JSON completo (objeto o array) por balanceo de llaves/corchetes.\n\nfunction getRaw(item) {\n  const j = item.json ?? {};\n  return j.output ?? j.text ?? j.message ?? j.content ?? j.data ?? j;\n}\n\nfunction extractFirstJsonValue(text) {\n  if (typeof text !== \"string\") text = String(text);\n\n  // Si viene dentro de ```json ... ``` o ``` ... ```, primero intenta sacar el contenido del fence\n  const fence = text.match(/```(?:json)?\\s*([\\s\\S]*?)\\s*```/i);\n  if (fence?.[1]) text = fence[1];\n\n  // Busca inicio de JSON: { o [\n  const startObj = text.indexOf(\"{\");\n  const startArr = text.indexOf(\"[\");\n  let start = -1;\n\n  if (startObj === -1) start = startArr;\n  else if (startArr === -1) start = startObj;\n  else start = Math.min(startObj, startArr);\n\n  if (start === -1) return null;\n\n  // Scanner para encontrar el final exacto del JSON (balanceando y respetando strings)\n  let inString = false;\n  let escape = false;\n  let depth = 0;\n  let opener = text[start];\n  let closer = opener === \"{\" ? \"}\" : \"]\";\n\n  for (let i = start; i < text.length; i++) {\n    const ch = text[i];\n\n    if (inString) {\n      if (escape) {\n        escape = false;\n      } else if (ch === \"\\\\\") {\n        escape = true;\n      } else if (ch === '\"') {\n        inString = false;\n      }\n      continue;\n    }\n\n    if (ch === '\"') {\n      inString = true;\n      continue;\n    }\n\n    if (ch === opener) depth++;\n    else if (ch === closer) depth--;\n\n    if (depth === 0) {\n      return text.slice(start, i + 1).trim();\n    }\n  }\n\n  // Si no cerró, no es JSON completo\n  return null;\n}\n\nfunction safeParseJson(text) {\n  // Limpieza ligera por si vienen comillas “ ”\n  const cleaned = text.replace(/[“”]/g, '\"').replace(/[‘’]/g, \"'\");\n  return JSON.parse(cleaned);\n}\n\n// --- MAIN ---\nconst out = [];\n\nfor (const item of items) {\n  const raw = getRaw(item);\n\n  // Si ya es objeto/array, pásalo directo\n  if (raw && typeof raw === \"object\") {\n    out.push({ json: raw });\n    continue;\n  }\n\n  const txt = String(raw);\n  const jsonStr = extractFirstJsonValue(txt);\n\n  if (!jsonStr) {\n    throw new Error(\n      \"No encontré un JSON completo en el texto. Primeros 300 chars:\\n\" +\n      txt.slice(0, 300)\n    );\n  }\n\n  const parsed = safeParseJson(jsonStr);\n  out.push({ json: parsed });\n}\n\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -240,
        32
      ],
      "id": "10c1ab68-92bc-4c8f-9ad4-1c72a274e6ad",
      "name": "Code in JavaScript"
    }
  ],
  "pinData": {},
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Code in JavaScript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Groq Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "binaryMode": "separate",
    "availableInMCP": false
  },
  "versionId": "a7e1dde5-c2f4-438a-a9d5-e843546fe6e1",
  "meta": {
    "instanceId": "8a7b9379a080e668be28594ac31a5112fea2cea9fc569fbd98bc97acc85cbba6"
  },
  "id": "N1k0zoJmSf7OZyJn6uKjR",
  "tags": []
}
